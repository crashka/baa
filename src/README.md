# ODB Integration

## Overview

Since the purpose of this fork is only to demonstrate how a relational database could be used as the
persistence mechanism for this project, I tried to touch the original source code as little as
possible.  But it was also important to show how the code for the ORM integration related to the
existing file-based persistence mechanism, so I have juxtaposed the two using the following pattern:

``` c++
#ifndef USE_ODB

    <original code here...>

#else

    <ODB equivalent code...>

#endif
```

Thus, the exact functionality of the original program is preserved in the absence of the `USE_ODB`
preprocessor symbol.  You can see the details of the code changes by diff'ing the commits in the
fork.

## ODB Pattern

For clarity, I will now present a distilled version of the ODB code used to implement the
RDBMS-based persistence for this program.  This can be considered a pattern for retrieving,
inserting, and updating data objects (encapsulated as `Finances` objects) to the database.  The
references to `USE_ODB` will be omitted here.

### finances.hpp

``` c++
#include <odb/core.hxx>

class Finances {
private:
    // give the ODB compiler access to the class members (which will become database columns)
    friend class odb::access;

    // the primary identifier of the user
    int digits;

    <other class members defined here...>
    
public:
    // default constructor
    Finances()
    {
        guaIncome =  guaExpend = remBudget = monthBudget = weekCounter = percentSave = percentWarning = 0;
    }
    
    <other class methods (including getters/setters) defined here...>
};

// declare `Finances` to be a database object; a SQL table definition (with the same name)
// will be generated
#pragma db object(Finances)

// declare `digits` to be the primary key for the table; this can be used by the ODB `load`
// or `find` method to retrieve a record, rather than having to build a query in order to
// locate and fetch
#pragma db member(Finances::digits) id
```

### main.cpp

``` c++
#include <odb/database.hxx>
#include <odb/transaction.hxx>
#include <odb/pgsql/database.hxx>

#include "finances.hpp"
#include "finances-odb.hpp"  // file generated by ODB compiler

using namespace std;
using namespace odb::core;

// command line arguments are passed through to the `odb::database` constructor
int main(int argc, char* argv[]) {
        .
        .
        .
    // pointer to the Finances record for the current user; note that this always represents
    // dynamic (i.e. heap) storage in this example file
    Finances *userInfo;

    // declare database handle to be used for the session
    unique_ptr<database> db(new odb::pgsql::database(argc, argv));

    <code to get `digits` (to see if this is a new or existing user) goes here...>

    // see if record for `digits` exists in the database...
    //
    // NOTE: we could also wrap all of the database operations within a single high-level
    // try-catch block, if database errors are always fatal to this program.  We could also
    // execute all of the operations (or just related ones) within a single transaction if
    // atomic commit/rollback was needed.  But, for demonstration purposes, we will do it
    // as follows, for clearer scoping and good citizenship on the exception handling.
    try {
        transaction t(db->begin());
        // this returns a pointer to a dynamic Finances object (or NULL, if not found)
        userInfo = db->find<Finances>(digits);
        t.commit();
    }
    catch (const odb::exception& e) {
        cerr << e.what() << endl;
        return 1;
    }
    bool found = (userInfo != NULL);

    // is when you dont have an account, allows user to set up account
    if (!found) {
        Finances newFinances;
      
        <code to set member values for `newFinances` stack object goes here...>

        // write `newFinances` as a new record in the database...
        try {
            int new_id;
            transaction t(db->begin());
            // the new primary key is returned, but there is no need to preserve here it
            // (since it is set by us [`digits`], rather than autogenerated)
            new_id = db->persist(newFinances);
            t.commit();
        }
        catch (const odb::exception& e) {
            cerr << e.what() << endl;
            return 1;
        }
        // create a copy on the heap for updating below (and so we can manage the storage
        // the same was as the "found" case)
        userInfo = new Finances(newFinances);
    }
    else {
        cout << "Your account has been found!" << endl;

        <code to set new member values for existing user (`userInfo`) goes here...>
    }

    <code to calculate remaining budget for `userInfo` (existing or new) goes here...>

    // write updates for Finances object (`*userInfo`) to the database...
    try {
        transaction t(db->begin());
        db->update(*userInfo);
        t.commit();
    }
    catch (const odb::exception& e) {
        cerr << e.what() << endl;
        return 1;
    }

    userInfo->menu(langCode);
    // this points to a heap object in both the new and existing user cases (even though
    // they have different construction methods)
    delete userInfo;
        .
        .
        .
}

```

[1]: https://www.postgresql.org/docs/12/auth-pg-hba-conf.html
[2]: https://www.postgresql.org/docs/12/auth-peer.html
